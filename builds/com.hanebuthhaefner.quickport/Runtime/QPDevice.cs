using System;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace QuickPortAPI
{
    /// <summary>
    /// The General implementation of a QuickPortDevice. Contains all necessary functions all virtual touch devices will need.
    /// </summary>
    /// <typeparam name="InputType">The type of Input this device will send, can be any type but needs to be of the types the Unity InputSystem accepts.</typeparam>
    public abstract class QPDevice<InputType> : MonoBehaviour, IPointerDownHandler, IPointerUpHandler where InputType : struct

    {
        /// <summary>
        /// A reference to the devices button component. This is useful to easily swap and change graphics.
        /// </summary>
        [SerializeField]Button _buttonComponent;
        protected bool _bIsActive = true;

        /// <summary>
        /// A Function that is used to send the devices default input. Mostly used to reset the device on disabling it so one last neutral input is sent.
        /// </summary>
        protected abstract InputType DefaultInput { get;}

        /// <summary>
        /// The event that is fired whenever input happens. Other classes can subscribe to this event.
        /// </summary>
        /// <typeparam name="TValue">The InputType of the device.</typeparam>
        /// <param name="value">The value that is passed through the event.</param>
        public delegate void SendInputCallback<TValue>(TValue value) where TValue : struct;
        public event SendInputCallback<InputType> e_OnInputSent;

        /// <summary>
        /// Binds the button component, that every device uses to swap images.
        /// </summary>
        protected virtual void Start()
        {
            BindButtonComponent();
        }

        /// <summary>
        /// Binds the button component to a local variable.
        /// </summary>
        void BindButtonComponent()
        {
            if(_buttonComponent != null)
            {
                return;
            }
            else if (this.GetComponent<Button>() != null)
            {
                _buttonComponent = this.GetComponent<Button>();
            }
            else
            {
                QuickPortLogger.QPLogError(this, "A Quickport Device requires a component of type button in order to function! \n Please add a component of type Button to the gameobject.");
            }
        }

        /// <summary>
        /// Makes sure deactivate is called to send neutral input before being disabled.
        /// </summary>
        void OnDisable()
        {
            Deactivate();
        }

        /// <summary>
        /// Makes sure deactivate is called to send neutral input before being destroyed.
        /// </summary>
        void OnDestroy()
        {
            Deactivate();
        }

        /// <summary>
        /// The function that is called to send input. This only throws the inputsent event.
        /// </summary>
        /// <param name="input">The input generated by the device.</param>
        protected void SendInput(InputType input)
        {
            e_OnInputSent?.Invoke(input);
        }

        public abstract void OnPointerDown(PointerEventData eventData);

        public abstract void OnPointerUp(PointerEventData eventData);

        /// <summary>
        /// Activates the devices functionality.
        /// To be called by other events or scripts via code.
        /// </summary>
        public void Activate()
        {
            if (_bIsActive)
            {
                return;
            }
            else
            {
                _bIsActive = true;
                _buttonComponent.interactable = true;
            }
        }

        /// <summary>
        /// Deactivates the devices funtionality.
        /// To be called by other events or scripts via code.
        /// </summary>
        public void Deactivate()
        {
            if (!_bIsActive)
            {
                return;
            }
            else
            {
                _bIsActive = false;
                _buttonComponent.interactable = false;
                SendNeutralInput();
            }
        }

        /// <summary>
        /// This method sends the value the inputdevice would send in a neutral state and is mainly used to handle resetting the input when disableing the device.
        /// </summary>
        void SendNeutralInput()
        {
            e_OnInputSent?.Invoke(DefaultInput);
        }

        /// <summary>
        /// Activates or Deactivates the Devices Functionality.
        /// </summary>
        public void ToggleActive()
        {
            if (_bIsActive)
            {
                Deactivate();
            }
            else
            {
                Activate();
            }
        }

    }
}
